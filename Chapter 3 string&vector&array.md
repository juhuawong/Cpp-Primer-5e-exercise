# 第3章 String，Vector和Array #
----------
## 3.1 Namespace using Declarations ##

### A Separate Declaration Is Required for Each Name ###

例子如using std::cin;这就使得我们再次使用cin的时候不需要带前缀std::，不过我们为了省事一般直接使用using namespace std;

### 在头文件中不使用using声明 ###
头文件一般都是直接拷贝到包含此头文件的程序中，如果头文件中包含using声明，可能会造成命名冲突。

## 3.2 string类型 ##

### 3.2.1 sting的声明和初始化 ###
一般的变量在声明的时候建议初始化。
两种方式：

- 直接初始化	`string s6("hiya");`和`string s7(10,'c');`

- 复制初始化 `string s5 = "hiya";`

### 3.2.2 string类型的操作 ###

- 读写操作

    `cin`是不读取空格的
    `getline`读取空格，这个函数只读取一行，返回`istream`类型
    `while(cin >> s)`可以使用ctrl+z键结束，ctrl+z在windows下模拟的是EOF。

#### string的empty和size操作 ####


- string类型的empty操作返回的是bool类型的值
- string的size操作返回的是strig::size_type类型，这是一个依赖机器的类型，在不同的机器上长度是不一样的，但无论在什么机器上，string::size_type能够容纳任何string类型的长度。

#### string的比较 ####

#### string的赋值 ####

#### 两个string相加 ####


### 3.2.3 string中的字符操作 ###


对string的操作有两个部分：

- 如何访问字符
- 如何改变字符

#### 使用基于Range的for循环操作每一个字符 ####

这是C++11里新添加的用法：
    `for(declaration:expression) statement`

这是操作string里每个字符最好的方法。

#### 使用Range for改变string里的每个字符 ####

### 只处理其中的一些字符 ###

### 使用下标作为迭代器 ###
使用下标访问string一定要确保索引在范围内，超出范围将会是未定义。

### 使用下标访问任意字符 ###


## 3.3 vector类型 ##
vector是一个类模板，通常说是一种容器。

### 3.3.1 定义和初始化vector类型 ###

#### 列表初始化 ####
这是C++11标准里才有的用法。`vector<string> articles = {"a","an","the"};`这里需要注意的是{}而不是（）。

#### 创建特定数量的元素 ####
    `vector<int> ivec(10,-1);`创建10个元素，每个元素是-1
    `vector<int> ivec(10);`	创建10个元素，每个元素的值为默认初始值

#### 列表初始化 ####
    vector<int> v1(10) //这是10个0
    vector<int> v2{10}//v2包含一个元素10
    vector<int> v3(10,1) //v3是10个1
    vector<int> v4{10,1} //v4包含2个元素，10和1

小括号一般用于函数，上面的用法是采用构造函数；大括号一般用于列表初始化。

### 3.3.2 往vector中增加元素 ###

我们可以使用`push_back()`函数往vector中添加元素。如果知道vector中元素的数量，最好提前指定元素的数量。

### 3.3.3 其他的vector操作 ###
#### 下标操作 ####

值得注意的是下标操作只能访问容器中的，并不能增加vector中的元素。


## 3.4 迭代器简介 ##

### 3.4.1 使用迭代器 ###

Note：如果容器为空，则begin和end返回的迭代器指向同一个地址。

#### 迭代器操作 ####

#### 利用迭代器从一个元素上移动到另一个元素 ####

Note：在C++中我们使用`！=`多于`<`，为什么？这是因为在容器中只有少数几个提供了下标操作，但是所有的容器都提供了迭代器操作，迭代器中总是会定义`=`和`！=`操作，但不见得会有`<`和`>`。所有采用`！=`无需担心我们处理的容器的准确类型。

#### 迭代器类型 ####

迭代我类型有两种：iterator和const_iterator。

#### begin和end操作 ####

如果对象是const类型，begin返回的类型是const_iterator。在C++11标准中引入了两个新的操作cbegin和cend，返回的类型都是const_iterator。

#### Combining Dereference and Member Access ####

### 迭代器的算术操作 ###

    iter + n
    iter - n

    iter1 += n
    iter2 -= n
    iter2 - iter1

    >,>=,<,<=

-----
## 3.5 数组 ##

Note：如果不知道需要多少个元素，采用vector更合适。

### 3.5.1 定义和初始化数组 ###

#### 显式初始化数组元素 ####

#### 字符数组是特殊的数组 ####

字符串常量是以空字符null结尾，如char `a3[] = "C++";`包含4个元素，最后还包含一个null。

#### 不能以复制和直接赋值的方式对数组进行初始化 ####

    int a[] = {0,1,2};
    int a2[] = a;//这是错误的使用方式，不能采用复制一个数组的方式初始化另一个数组
    a2 = a;//不能把一个数组直接赋值给另一个数组

#### 理解复杂的数组声明 ####

    int *ptrs[10];//ptrs是10个指向int的指针的数组
    int &refs[10] = /*?*/;//没有引用的数组
    int (*Parry)[10] = &arr;//Parry是指向数组的指针
    int (&arrRef)[10] = arr;//arrRef是数组的引用；
怎么区分，如果不含有括号，如ptrs则从右往左读，ptrs是10个数组，数组中包含的数据是指向int的指针；如果含有括号，如Parry则从里往外，再从右往左读，Parry是一个指针，指向大小为10的数组，数组中的元素是int类型。再有`int *(&arry)[10] = ptrs;`就知道arry是一个引用，是长度为10的数组的引用，数组中的类型是指向int的指针。

### 3.5.2 访问数组中的元素 ###

与string和vector类似，最好使用Range for遍历整个数组。
    for(auto i:scorces) cout << i << " ";

#### 使用下标访问数组元素 ####

使用下标访问数组的时候一定要确保下标值在范围内。使用下标访问数据的时候一般需要定义一个size_t的类型，这是一个依赖机器的类型，是一个无符号类型，足够容纳任何类型的长度。还有一个比较类似的概念是`string::size_type`,这个类型一般是为了与string.size()的返回值进行比较。

`size_t`是一个全局范围内的定义的类型，而`size_type`是STL类中定义的属性，用以保存任意string和vector的长度。

----
### 3.5、3 指针和数组 ###

Note：在大多数表达式中，当我们使用数组类型的对象，实际上是使用指针指向数组中的第一个元素。

#### 指针是迭代器 ####

我们使用数组的第一个表示元素作为第一个指针，但是怎么表示最后一个元素的下一个指针呢？**采用一个不存在的数组元素**。

	int arr[] = {0,1,2,3,4,5,6,7,8,9};;
	int *p = arr;//p指向数组arr的第一个元素
	int *e = arr[10];//e指向数组arr的最后一个值

#### 库函数中的begin和end函数 ####

在标准C++中新增加了begin和end函数，使得使用函数更加简单安全。但是需要注意的是由于数组不是类型，begin和end不是成员函数，使用方法如下：

	int ia[] = {0,1,2,3,4,5,6,7,8,9};
	int *beg = begin(ia);//ia中的第一个元素
	int *end = end(ia);  //ia中的最后一个元素的下一个位置
这两个函数包含在iterator头文件中。

#### 指针计算 ####

#### 取值和指针运算之间的相互关系 ####

#### 下标和指针 ####

与vector和string的下标不同，数组的下标可以是负数。